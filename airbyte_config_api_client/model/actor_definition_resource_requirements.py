# coding: utf-8

"""
    Airbyte Configuration API

    Airbyte Configuration API [https://airbyte.io](https://airbyte.io).  This API is a collection of HTTP RPC-style methods. While it is not a REST API, those familiar with REST should find the conventions of this API recognizable.  Here are some conventions that this API follows: * All endpoints are http POST methods. * All endpoints accept data via `application/json` request bodies. The API does not accept any data via query params. * The naming convention for endpoints is: localhost:8000/{VERSION}/{METHOD_FAMILY}/{METHOD_NAME} e.g. `localhost:8000/v1/connections/create`. * For all `update` methods, the whole object must be passed in, even the fields that did not change.  Authentication (OSS): * When authenticating to the Configuration API, you must use Basic Authentication by setting the Authentication Header to Basic and base64 encoding the username and password (which are `airbyte` and `password` by default - so base64 encoding `airbyte:password` results in `YWlyYnl0ZTpwYXNzd29yZA==`). So the full header reads `'Authorization': \"Basic YWlyYnl0ZTpwYXNzd29yZA==\"`   # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: contact@airbyte.io
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from airbyte_config_api_client import schemas  # noqa: F401


class ActorDefinitionResourceRequirements(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
    """


    class MetaOapg:
        
        class properties:
        
            @staticmethod
            def default() -> typing.Type['ResourceRequirements']:
                return ResourceRequirements
            
            
            class jobSpecific(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    @staticmethod
                    def items() -> typing.Type['JobTypeResourceLimit']:
                        return JobTypeResourceLimit
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['JobTypeResourceLimit'], typing.List['JobTypeResourceLimit']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'jobSpecific':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'JobTypeResourceLimit':
                    return super().__getitem__(i)
            __annotations__ = {
                "default": default,
                "jobSpecific": jobSpecific,
            }
        additional_properties = schemas.NotAnyTypeSchema
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["default"]) -> 'ResourceRequirements': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["jobSpecific"]) -> MetaOapg.properties.jobSpecific: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["default"], typing_extensions.Literal["jobSpecific"], ]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["default"]) -> typing.Union['ResourceRequirements', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["jobSpecific"]) -> typing.Union[MetaOapg.properties.jobSpecific, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["default"], typing_extensions.Literal["jobSpecific"], ]):
        return super().get_item_oapg(name)

    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, ],
        default: typing.Union['ResourceRequirements', schemas.Unset] = schemas.unset,
        jobSpecific: typing.Union[MetaOapg.properties.jobSpecific, list, tuple, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
    ) -> 'ActorDefinitionResourceRequirements':
        return super().__new__(
            cls,
            *_args,
            default=default,
            jobSpecific=jobSpecific,
            _configuration=_configuration,
        )

from airbyte_config_api_client.model.job_type_resource_limit import JobTypeResourceLimit
from airbyte_config_api_client.model.resource_requirements import ResourceRequirements
